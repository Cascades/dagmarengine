<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no"><title>dagmar_website</title><link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Catamaran:100,200,300,400,500,600,700,800,900"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:100,100i,300,300i,400,400i,700,700i,900,900i"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Archivo+Black"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Armata"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"><link rel="stylesheet" href="assets/css/styles.min.css"></head><body style="color: rgb(33,37,41);"><section class="d-flex d-sm-flex d-md-flex d-lg-flex d-xl-flex justify-content-center justify-content-sm-center justify-content-md-center justify-content-lg-center" style="width: 100%;height: auto;background: #252424;color: rgb(33, 37, 41);padding-bottom: 10px;min-height: 100vh;margin-bottom: 0px;"><div class="d-sm-flex d-md-flex flex-column align-items-sm-center justify-content-md-center justify-content-xl-start detail_page" style="background: rgb(210,208,208);padding-bottom: 0px;"><header class="d-flex d-sm-flex d-xl-flex justify-content-center justify-content-sm-center justify-content-xl-center align-items-xl-center" style="width: 100%;background: rgba(255,255,255,0);height: auto;position: relative;padding-top: 12px;"><h1 class="d-md-flex justify-content-md-center" style="font-size: 62px;">Physics</h1></header><div class="d-flex d-sm-flex d-md-flex d-xl-flex flex-column align-items-center align-items-sm-center align-items-md-center justify-content-xl-start align-items-xl-center" style="width: 100%;padding-top: 10px;height: auto;padding-bottom: 20px;"><div class="d-sm-flex d-xl-flex justify-content-sm-center justify-content-xl-center align-items-xl-center" style="width: 90%;height: auto;padding-top: 29px;"><p class="text-justify" style="width: 100%;margin-bottom: 0px;"><strong>Physics</strong><br>Our homebrew physics library uses Dagmarâ€™s Entity Component System to efficiently iterate through entities which have a rigid body component to produce realistic collision responses in real-time.<br><br><strong>Collision Detection &amp; Response</strong><br>Our system currently supports two types of rigid body collider primitives, which are components in our ECS. The first are spheres, and the second are Axis Aligned Bounding Boxes (AABBs). Even with just these two primitives, a wide array of fun and realistic scenes can be produced easily.<br><br>Collision between two sphere rigid bodies is a quick calculation checking that the distance between their centers is no more than the sum of their two radii. If this is true, there is a collision. The collision response then sets the sphere positions to be so that their surfaces just touch, and their force and velocity are reflected over the vector between the two centers.<br><br>Collision between two AABBs is also a relatively quick calculation, however slower than the previous sections. We perform six well researched checks for whether there is any overlap between the volumes defined by the AABBs. If there is, the collision response involves once again setting the position of each AABB so that the collided pair only just touches. We then take the angle between the vector between both AABB centers, and compare it to each of the positive and negative basis vectors in our space. Whichever basis comparison is smallest, we use that basis vector as the force reflection vector, similar to sphere-sphere collision. There is also a normalization process that takes place (as AABBs are rarely square).<br>Finally, a similar process to AABB-AABB collision takes place for AABB-sphere collision and response.<br><br><strong>Multi-Threading</strong><br>While we considered using GPU compute shaders, we found it to be unnecessary, both because we were getting good results on the CPU for our test sets, and also because of project time constraints.<br>We did, however, multi-thread the process. We were able to split up the outer loop of our iteration, and divide it into disjoint sections based on the number of threads allocated to physics. Because the sets of entities were disjoint, we did not have to worry about common multi-threading issues like race conditions.<br>We were also able to orchestrate a system for dynamically re-allocating the number of physics threads. Each thread would check a signal each loop, and if triggered, would wait for all threads to shut down. We would then set off a new batch of threads. This should allow for capping the resources consumed by physics in real-time if required by the system, however we never needed to use it in practice.<br><br><strong>Voxel Optimisations</strong><br>The final aspect of the physics system was to optimise AABB and sphere collision with the voxel world. A naive solution would be to iterate over each individual voxel to check for collision, however this gets ridiculously slow, very quickly. Instead we calculate the positions of each voxel the surfaces of our rigid bodies could be intersecting with, and check whether they are active. This reduces the complexity of collision check in most cases, as long as our voxel structure is larger than our intersecting objects. Since a single voxel is guaranteed to be an AABB, we reuse the previous algorithms for AABB-voxel and sphere-voxel response.<br></p></div></div></div></section><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.6.0/js/bootstrap.bundle.min.js"></script></body></html>